# Demo Script — NebulaVRF Deliverables (Testnet Contract + SDK)

> Read this word‑for‑word while recording. Replace bracketed fields (like `<CONTRACT_ID>`) with your actual values.

---

## 0:00–0:20 — Intro (What is NebulaVRF?)

“Hi everyone, this is NebulaVRF — a verifiable randomness system built for Soroban on Stellar.  
It uses a commit–reveal scheme with BLS signatures so outcomes are **fair**, **auditable**, and **tamper‑resistant**.  
In this video, I’ll show two deliverables:  
one, the testnet smart contract and full workflow;  
two, the NebulaVRF Rust SDK that generates randomness locally with optional on‑chain verification.”

---

## 0:20–0:45 — Use case (DAO example)

“Let’s take a real example. Imagine a DAO needs to select a random committee for a vote.  
You need randomness that **no one can manipulate**, and that **everyone can verify**.  
NebulaVRF solves that by locking the randomness first, and only revealing it later with proof.”

---

## 0:45–1:10 — Explain Commit–Reveal (Plain English)

“Here’s the core idea in simple terms.  
Commit–reveal is a two‑step process to keep randomness fair:

**Step 1: Commit.**  
I choose a secret value, then publish only its hash.  
This is like putting a number in a sealed envelope and showing everyone the envelope.

**Step 2: Reveal.**  
Later I open the envelope and show the actual value.  
Because the hash was already published, everyone can verify I didn’t change it.

So commit–reveal prevents last‑minute manipulation and makes the randomness verifiable.”

---

## 1:10–1:30 — Explain G1 and G2 (Plain English)

“You’ll also hear ‘G1’ and ‘G2’.  
These are just two different groups of points on the BLS12‑381 curve, used for signatures.

Think of them like two different coordinate systems:
- **G1** is where the public key lives.  
- **G2** is where the signature lives.

For this contract:
- **G1 public key** is 96 bytes (uncompressed).  
- **G2 signature** is 192 bytes (uncompressed).

You don’t need to do the math yourself — the SDK handles it — but the sizes must match exactly.”

---

## 0:45–1:00 — Open Stellar Lab + Contract

“I’m opening Stellar Lab and loading the NebulaVRF testnet contract.  
The contract exposes five public functions:  
`commit`, `reveal`, `derive_random`, `get_commitment`, and `get_pubkey`.”

---

## 1:00–1:50 — Commit (Lock in randomness)

“First we call **commit**.  
Commit does one thing: it stores a hash of my randomness and my BLS public key.  
That means I cannot change the randomness later — it’s locked in.”

**Function:** `commit(user, commitment, pubkey)`

**Parameters explained:**
- **user**: my Stellar address, which must authorize the call.  
- **commitment**: a 32‑byte hash of `seed || salt`.  
- **pubkey**: my BLS public key, **G1**, **96 bytes**, uncompressed.

**How these values are generated:**
1. I generate a random `seed` and random `salt`.  
2. I compute `commitment = sha256(seed || salt)`.  
3. I sign that commitment with BLS and use the corresponding **G1 pubkey**.

“For this demo I’m using values generated by the SDK helper so everything matches the contract’s expected format.”

*(Paste values into Stellar Lab)*  
`user = <YOUR_ADDRESS>`  
`commitment = <BASE64_COMMITMENT>`  
`pubkey = <BASE64_G1_PUBKEY>`

“Now I submit the transaction. Commit is successful.”

---

## 1:50–2:40 — Reveal (Prove the randomness)

“Next I call **reveal**.  
Reveal proves my randomness is valid by checking the commitment and verifying the BLS signature on‑chain.”

**Function:** `reveal(user, seed, salt, signature)`

**Parameters explained:**
- **user**: same address used in commit.  
- **seed**: the original seed bytes.  
- **salt**: the original salt bytes.  
- **signature**: BLS signature on `sha256(seed || salt)`, **G2**, **192 bytes**, uncompressed.

**How these values are generated:**
1. `seed` and `salt` are the same values used in commit.  
2. The signature is created over the commitment using DST  
   `NEBULA‑VRF‑V01‑BLS12381G2`.

“I’ll paste the matching seed, salt, and signature from the SDK output.”

*(Paste values into Stellar Lab)*  
`user = <YOUR_ADDRESS>`  
`seed = <BASE64_SEED>`  
`salt = <BASE64_SALT>`  
`signature = <BASE64_G2_SIGNATURE>`

“When I submit, the contract recomputes the commitment, verifies the signature, and returns a 32‑byte randomness value.”

---

## 2:40–3:10 — Derive Random (App‑specific randomness)

“Now I call **derive_random**, which turns the 32‑byte randomness into a deterministic `u64` for a specific context.  
This lets me use the same randomness for multiple use cases without collision.”

**Function:** `derive_random(randomness, context)`

**Parameters explained:**
- **randomness**: the BytesN<32> returned from reveal.  
- **context**: any bytes used to namespace the randomness.

“For a DAO committee selection, I’ll use context `dao_vote_7`.”  
Base64 for `dao_vote_7` is: `ZGFvX3ZvdGVfNw==`.

*(Paste values into Stellar Lab)*  
`randomness = <FROM_REVEAL_RESULT>`  
`context = ZGFvX3ZvdGVfNw==`

“The output is a deterministic `u64` that the DAO can use for fair selection.”

---

## 3:10–3:30 — Optional Reads

“We also have read methods:  
`get_commitment` returns what’s stored for a user, and  
`get_pubkey` returns their public key.  
These are useful for verifying stored state.”

---

# Deliverable 4 — NebulaVRF SDK (Rust Crate)

## 3:30–3:50 — SDK Overview

“Now I’ll show Deliverable 4: the NebulaVRF Rust SDK.  
This lets developers generate randomness **locally**, then optionally verify it on‑chain.”

---

## 3:50–4:20 — Generate Payloads Locally

“The SDK includes a demo helper to generate correct testnet payloads.”

Command:
```
cargo run --example sample_payloads
```

“This prints seed, salt, commitment, pubkey, and signature — in both hex and base64.”

---

## 4:20–4:40 — Local API (Optional)

“There’s also a local HTTP API so developers can get payloads programmatically.”

Command:
```
cargo run --bin nebula_vrf_api --features api
```

Endpoints:
- `GET http://localhost:3000/payloads`  
- `GET http://localhost:3000/payloads?seed_len=8&salt_len=8`

---

## 4:40–5:00 — Closing

“So that’s the full story:  
NebulaVRF provides a testnet contract for verifiable randomness  
and a Rust SDK for generating randomness locally.  
Together, they give developers a full, auditable commit–reveal workflow.”
